# 🏗️ 项目架构重构说明

## 📁 新的项目结构

```
WindowScope/
├── src/                           # 源代码目录
│   ├── __init__.py
│   │
│   ├── config/                    # 配置模块
│   │   ├── __init__.py
│   │   └── settings.py            # 集中配置管理
│   │
│   ├── core/                      # 核心业务逻辑
│   │   ├── __init__.py
│   │   └── capture_engine.py     # 捕获引擎（信号驱动）
│   │
│   ├── ui/                        # 用户界面层
│   │   ├── __init__.py
│   │   ├── main_window.py        # 主窗口
│   │   ├── capture_window.py     # 监视窗口
│   │   └── region_selector.py    # 区域选择器
│   │
│   ├── utils/                     # 工具模块
│   │   ├── __init__.py
│   │   ├── logger.py             # 日志管理器
│   │   └── win32_helper.py       # Windows API 封装
│   │
│   └── main.py                    # 应用程序入口
│
├── window_capture_pyqt6.py        # 原版本（作为备份）
├── requirements.txt               # 依赖列表
└── README.md                      # 项目说明
```

## 🎯 设计原则

### 1. SOLID 原则

#### S - 单一职责原则 (Single Responsibility)
- **CaptureEngine**: 只负责捕获逻辑
- **RegionSelector**: 只负责区域选择 UI
- **Logger**: 只负责日志记录
- **ScreenCapture**: 只负责屏幕捕获方法

#### O - 开闭原则 (Open/Closed)
- 使用配置文件而非硬编码
- 通过继承和接口扩展功能
- 新增捕获方法不需要修改现有代码

#### L - 里氏替换原则 (Liskov Substitution)
- 所有 QObject 子类可互相替换
- 捕获方法遵循统一接口

#### I - 接口隔离原则 (Interface Segregation)
- 使用 PyQt6 信号机制实现松耦合
- 各模块只依赖需要的接口

#### D - 依赖倒置原则 (Dependency Inversion)
- 高层模块（UI）不直接依赖低层模块（捕获）
- 通过信号/槽机制实现解耦

### 2. 关注点分离

```
UI 层 (ui/)
    ↓ 信号/槽
核心层 (core/)
    ↓ 调用
工具层 (utils/)
```

### 3. 模块化设计

每个模块都是独立的、可测试的单元：

```python
# 配置模块 - 数据类
@dataclass
class AppSettings:
    ...

# 核心模块 - 业务逻辑
class CaptureEngine(QObject):
    frame_captured = pyqtSignal(QImage)
    ...

# UI 模块 - 界面展示
class CaptureWindow(QDialog):
    def __init__(self, engine: CaptureEngine):
        engine.frame_captured.connect(self.on_frame)
    ...
```

## 📋 核心模块详解

### 1. 配置模块 (`config/settings.py`)

**职责**: 集中管理所有配置项

**优点**:
- ✅ 避免魔法数字
- ✅ 易于维护和修改
- ✅ 类型安全（使用 dataclass）

```python
@dataclass
class CaptureSettings:
    default_fps: int = 30
    min_fps: int = 1
    max_fps: int = 60
    ...

settings = AppSettings()  # 全局单例
```

### 2. 日志模块 (`utils/logger.py`)

**职责**: 统一的日志记录

**优点**:
- ✅ 单例模式，全局一致
- ✅ 支持多种输出（控制台、文件）
- ✅ 标准的日志级别（DEBUG, INFO, WARNING, ERROR）
- ✅ 易于扩展（如发送到远程服务器）

```python
logger = Logger()  # 全局单例
logger.info("应用启动")
logger.error("捕获失败")
```

### 3. Windows 工具模块 (`utils/win32_helper.py`)

**职责**: 封装 Windows API 调用

**优点**:
- ✅ 隔离底层 API 细节
- ✅ 提供高层次的抽象
- ✅ 统一的错误处理
- ✅ 易于测试（可以 mock）

```python
class WindowManager:
    @staticmethod
    def enum_windows() -> List[Tuple[int, str]]:
        ...

class ScreenCapture:
    @staticmethod
    def capture_window(hwnd, width, height):
        ...
```

### 4. 捕获引擎 (`core/capture_engine.py`)

**职责**: 核心捕获逻辑，使用信号驱动

**优点**:
- ✅ 与 UI 完全解耦
- ✅ 可独立测试
- ✅ 事件驱动架构
- ✅ 易于扩展功能

```python
class CaptureEngine(QObject):
    # 信号定义
    frame_captured = pyqtSignal(QImage)
    capture_failed = pyqtSignal(str)
    fps_updated = pyqtSignal(float)
    
    def start(self): ...
    def pause(self): ...
    def set_fps(self, fps): ...
```

### 5. UI 组件 (`ui/`)

**职责**: 用户界面展示和交互

**优点**:
- ✅ 只负责显示和用户交互
- ✅ 不包含业务逻辑
- ✅ 通过信号与核心层通信
- ✅ 易于重新设计 UI

## 🔄 数据流

### 捕获流程

```
用户点击"启动监视"
    ↓
MainWindow.start_capture()
    ↓
创建 CaptureEngine
    ↓
创建 CaptureWindow
    ↓
engine.frame_captured → window.on_frame()
    ↓
显示图像
```

### 信号流

```
CaptureEngine (核心层)
    ├─ frame_captured → CaptureWindow.on_frame()
    ├─ fps_updated → CaptureWindow.update_fps()
    ├─ method_changed → CaptureWindow.update_method()
    └─ capture_failed → CaptureWindow.on_error()
```

## 🎨 架构模式

### MVC 变体 (Model-View-Controller)

```
Model (core/)
  - CaptureEngine
  - 业务逻辑

View (ui/)
  - MainWindow
  - CaptureWindow
  - RegionSelector
  - UI 展示

Controller (隐式)
  - Qt 信号/槽机制
  - 事件处理
```

### 观察者模式

使用 PyQt6 的信号/槽机制实现：

```python
# 发布者
class CaptureEngine(QObject):
    frame_captured = pyqtSignal(QImage)

# 订阅者
class CaptureWindow(QDialog):
    def __init__(self, engine):
        engine.frame_captured.connect(self.on_frame)
```

### 单例模式

```python
# Logger 单例
logger = Logger()

# Settings 单例
settings = AppSettings()
```

## 📈 相比原架构的优势

### 原架构 (单文件)

```
window_capture_pyqt6.py (981 行)
    ├─ 全局函数
    ├─ 数据结构定义
    ├─ UI 类
    └─ 业务逻辑
```

**问题**:
- ❌ 代码耦合度高
- ❌ 难以测试
- ❌ 难以维护
- ❌ 重用性差

### 新架构 (模块化)

```
src/
├─ config/    (配置)
├─ core/      (核心逻辑)
├─ ui/        (界面)
└─ utils/     (工具)
```

**优势**:
- ✅ 关注点分离
- ✅ 易于测试
- ✅ 易于维护
- ✅ 高度可重用
- ✅ 易于扩展

## 🧪 可测试性

### 单元测试示例

```python
# 测试捕获引擎
def test_capture_engine():
    engine = CaptureEngine(hwnd=12345, region=(0,0,100,100))
    
    # 测试信号
    with qtbot.waitSignal(engine.frame_captured):
        engine.start()

# 测试窗口管理器
def test_enum_windows():
    windows = WindowManager.enum_windows()
    assert len(windows) > 0
```

### 集成测试

```python
def test_full_workflow():
    app = QApplication()
    main_window = MainWindow()
    # 模拟用户操作
    ...
```

## 🔧 扩展性

### 添加新的捕获方法

只需在 `ScreenCapture` 类中添加：

```python
class ScreenCapture:
    @staticmethod
    def capture_window_new_method(hwnd, width, height):
        ...
    
    @classmethod
    def capture_window(cls, hwnd, width, height):
        # 尝试新方法
        img, ok = cls.capture_window_new_method(...)
        if ok:
            return img, "new_method"
        ...
```

### 添加新的 UI 功能

创建新的 UI 组件：

```python
# src/ui/settings_dialog.py
class SettingsDialog(QDialog):
    ...
```

### 添加配置项

在 `settings.py` 中添加：

```python
@dataclass
class NewSettings:
    option1: bool = True
    ...

@dataclass
class AppSettings:
    new: NewSettings = NewSettings()
```

## 📚 文件职责说明

| 文件 | 职责 | 行数 | 依赖 |
|------|------|------|------|
| `config/settings.py` | 配置管理 | ~60 | 标准库 |
| `utils/logger.py` | 日志管理 | ~80 | logging |
| `utils/win32_helper.py` | Windows API | ~200 | win32gui, PyQt6 |
| `core/capture_engine.py` | 捕获引擎 | ~150 | utils, config |
| `ui/region_selector.py` | 区域选择器 | ~250 | utils, config |
| `ui/capture_window.py` | 监视窗口 | ~200 | core, utils |
| `ui/main_window.py` | 主窗口 | ~300 | ui, core, utils |
| `main.py` | 程序入口 | ~50 | ui, config |

**总计**: ~1,290 行（比原来的 981 行略多，但更易维护）

## 🎓 学习要点

### 1. 依赖注入

```python
# 不好的做法（硬编码依赖）
class CaptureWindow:
    def __init__(self):
        self.engine = CaptureEngine()  # 硬编码

# 好的做法（依赖注入）
class CaptureWindow:
    def __init__(self, engine: CaptureEngine):
        self.engine = engine  # 注入依赖
```

### 2. 信号驱动

```python
# 不好的做法（直接调用）
class CaptureEngine:
    def capture(self):
        img = ...
        self.window.display(img)  # 直接调用

# 好的做法（信号驱动）
class CaptureEngine(QObject):
    frame_captured = pyqtSignal(QImage)
    
    def capture(self):
        img = ...
        self.frame_captured.emit(img)  # 发射信号
```

### 3. 配置管理

```python
# 不好的做法（魔法数字）
if fps < 1 or fps > 60:
    ...

# 好的做法（使用配置）
if fps < settings.capture.min_fps or fps > settings.capture.max_fps:
    ...
```

## 🚀 迁移指南

从旧版本迁移到新架构：

1. **安装依赖** (相同)
   ```bash
   pip install pywin32 PyQt6
   ```

2. **运行新版本**
   ```bash
   python src/main.py
   ```

3. **保留旧版本**
   ```bash
   # 旧版本仍然可用
   python window_capture_pyqt6.py
   ```

## 📖 总结

新架构的核心思想：

1. **模块化** - 每个模块职责单一
2. **解耦** - 通过信号/配置降低耦合
3. **可测试** - 独立的模块易于测试
4. **可扩展** - 遵循开闭原则
5. **可维护** - 清晰的结构易于维护

这是一个符合现代软件工程最佳实践的架构！🎉

